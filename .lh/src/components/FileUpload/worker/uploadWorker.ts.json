{
    "sourceFile": "src/components/FileUpload/worker/uploadWorker.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1748903553797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748903570377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,9 +63,9 @@\n     if (!exist) needUploadChunks.push(i);\r\n   }\r\n \r\n   // 记录已完成的分片数量，用于计算进度\r\n-  let completedChunks = chunkCount - needUploadChunks.length;\r\n+  const completedChunks = chunkCount - needUploadChunks.length;\r\n   let totalUploadedChunks = completedChunks;\r\n \r\n   // 3. 分片上传 - 使用 p-queue 进行并发控制\r\n   const uploadTasks = needUploadChunks.map((i) => {\r\n"
                },
                {
                    "date": 1748903578661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,7 @@\n+// 声明 Web Worker 环境的 importScripts 函数\r\n+declare function importScripts(...urls: string[]): void;\r\n+\r\n // @ts-expect-error: self 类型\r\n importScripts(\"https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js\");\r\n importScripts(\"https://cdn.jsdelivr.net/npm/p-queue@7.3.4/dist/index.min.js\");\r\n \r\n"
                },
                {
                    "date": 1748903585666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,7 @@\n // 声明 Web Worker 环境的 importScripts 函数\r\n declare function importScripts(...urls: string[]): void;\r\n \r\n-// @ts-expect-error: self 类型\r\n importScripts(\"https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js\");\r\n importScripts(\"https://cdn.jsdelivr.net/npm/p-queue@7.3.4/dist/index.min.js\");\r\n \r\n declare const SparkMD5: {\r\n"
                },
                {
                    "date": 1748903822915,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,24 +1,62 @@\n // 声明 Web Worker 环境的 importScripts 函数\r\n declare function importScripts(...urls: string[]): void;\r\n \r\n importScripts(\"https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js\");\r\n-importScripts(\"https://cdn.jsdelivr.net/npm/p-queue@7.3.4/dist/index.min.js\");\r\n \r\n declare const SparkMD5: {\r\n   ArrayBuffer: { hash(buf: ArrayBuffer): string };\r\n };\r\n \r\n-// p-queue 类型声明\r\n-declare const PQueue: {\r\n-  new (options?: { concurrency?: number; autoStart?: boolean }): {\r\n-    add: <T>(fn: () => Promise<T>) => Promise<T>;\r\n-    onIdle: () => Promise<void>;\r\n-    size: number;\r\n-    pending: number;\r\n-  };\r\n-};\r\n+/**\r\n+ * 简单的任务队列控制器实现\r\n+ */\r\n+class SimpleQueue {\r\n+  private concurrency: number;\r\n+  private running: number = 0;\r\n+  private queue: Array<() => Promise<any>> = [];\r\n \r\n+  constructor(options: { concurrency: number }) {\r\n+    this.concurrency = options.concurrency;\r\n+  }\r\n+\r\n+  add<T>(fn: () => Promise<T>): Promise<T> {\r\n+    return new Promise<T>((resolve, reject) => {\r\n+      // 包装任务，确保完成后运行下一个\r\n+      const wrapped = async () => {\r\n+        this.running++;\r\n+        try {\r\n+          const result = await fn();\r\n+          resolve(result);\r\n+          return result;\r\n+        } catch (error) {\r\n+          reject(error);\r\n+          throw error;\r\n+        } finally {\r\n+          this.running--;\r\n+          this.next();\r\n+        }\r\n+      };\r\n+\r\n+      // 如果可以立即运行，则运行\r\n+      if (this.running < this.concurrency) {\r\n+        wrapped();\r\n+      } else {\r\n+        // 否则加入队列\r\n+        this.queue.push(wrapped);\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  // 运行队列中的下一个任务\r\n+  private next() {\r\n+    if (this.queue.length > 0 && this.running < this.concurrency) {\r\n+      const fn = this.queue.shift();\r\n+      if (fn) fn();\r\n+    }\r\n+  }\r\n+}\r\n+\r\n self.onmessage = async (e) => {\r\n   const { fileInfo, fileBuffer, networkParams } = e.data;\r\n   const chunkSize = fileInfo.chunkSize || 1024 * 1024;\r\n   const chunkCount = Math.ceil(fileBuffer.byteLength / chunkSize);\r\n@@ -26,9 +64,9 @@\n   // 使用网络参数中的分片并发数，如果没有则默认为2\r\n   const chunkConcurrency = networkParams?.chunkConcurrency || 2;\r\n \r\n   // 创建队列，限制并发请求数\r\n-  const queue = new PQueue({ concurrency: chunkConcurrency });\r\n+  const queue = new SimpleQueue({ concurrency: chunkConcurrency });\r\n \r\n   const chunk_md5s: string[] = [];\r\n   // 1. 计算所有分片的md5\r\n   for (let i = 0; i < chunkCount; i++) {\r\n@@ -68,9 +106,9 @@\n   // 记录已完成的分片数量，用于计算进度\r\n   const completedChunks = chunkCount - needUploadChunks.length;\r\n   let totalUploadedChunks = completedChunks;\r\n \r\n-  // 3. 分片上传 - 使用 p-queue 进行并发控制\r\n+  // 3. 分片上传 - 使用简单队列进行并发控制\r\n   const uploadTasks = needUploadChunks.map((i) => {\r\n     return async () => {\r\n       const start = i * chunkSize;\r\n       const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n"
                },
                {
                    "date": 1748903849935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,73 +1,15 @@\n-// 声明 Web Worker 环境的 importScripts 函数\r\n-declare function importScripts(...urls: string[]): void;\r\n-\r\n+// @ts-expect-error: self 类型\r\n importScripts(\"https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js\");\r\n \r\n declare const SparkMD5: {\r\n   ArrayBuffer: { hash(buf: ArrayBuffer): string };\r\n };\r\n \r\n-/**\r\n- * 简单的任务队列控制器实现\r\n- */\r\n-class SimpleQueue {\r\n-  private concurrency: number;\r\n-  private running: number = 0;\r\n-  private queue: Array<() => Promise<any>> = [];\r\n-\r\n-  constructor(options: { concurrency: number }) {\r\n-    this.concurrency = options.concurrency;\r\n-  }\r\n-\r\n-  add<T>(fn: () => Promise<T>): Promise<T> {\r\n-    return new Promise<T>((resolve, reject) => {\r\n-      // 包装任务，确保完成后运行下一个\r\n-      const wrapped = async () => {\r\n-        this.running++;\r\n-        try {\r\n-          const result = await fn();\r\n-          resolve(result);\r\n-          return result;\r\n-        } catch (error) {\r\n-          reject(error);\r\n-          throw error;\r\n-        } finally {\r\n-          this.running--;\r\n-          this.next();\r\n-        }\r\n-      };\r\n-\r\n-      // 如果可以立即运行，则运行\r\n-      if (this.running < this.concurrency) {\r\n-        wrapped();\r\n-      } else {\r\n-        // 否则加入队列\r\n-        this.queue.push(wrapped);\r\n-      }\r\n-    });\r\n-  }\r\n-\r\n-  // 运行队列中的下一个任务\r\n-  private next() {\r\n-    if (this.queue.length > 0 && this.running < this.concurrency) {\r\n-      const fn = this.queue.shift();\r\n-      if (fn) fn();\r\n-    }\r\n-  }\r\n-}\r\n-\r\n self.onmessage = async (e) => {\r\n-  const { fileInfo, fileBuffer, networkParams } = e.data;\r\n+  const { fileInfo, fileBuffer } = e.data;\r\n   const chunkSize = fileInfo.chunkSize || 1024 * 1024;\r\n   const chunkCount = Math.ceil(fileBuffer.byteLength / chunkSize);\r\n-\r\n-  // 使用网络参数中的分片并发数，如果没有则默认为2\r\n-  const chunkConcurrency = networkParams?.chunkConcurrency || 2;\r\n-\r\n-  // 创建队列，限制并发请求数\r\n-  const queue = new SimpleQueue({ concurrency: chunkConcurrency });\r\n-\r\n   const chunk_md5s: string[] = [];\r\n   // 1. 计算所有分片的md5\r\n   for (let i = 0; i < chunkCount; i++) {\r\n     const start = i * chunkSize;\r\n@@ -102,58 +44,34 @@\n     )?.exist;\r\n     if (!exist) needUploadChunks.push(i);\r\n   }\r\n \r\n-  // 记录已完成的分片数量，用于计算进度\r\n-  const completedChunks = chunkCount - needUploadChunks.length;\r\n-  let totalUploadedChunks = completedChunks;\r\n+  // 3. 分片上传\r\n+  for (let i = 0; i < chunkCount; i++) {\r\n+    if (!needUploadChunks.includes(i)) continue;\r\n+    const start = i * chunkSize;\r\n+    const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n+    const chunk = fileBuffer.slice(start, end);\r\n+    const chunkMd5 = chunk_md5s[i];\r\n \r\n-  // 3. 分片上传 - 使用简单队列进行并发控制\r\n-  const uploadTasks = needUploadChunks.map((i) => {\r\n-    return async () => {\r\n-      const start = i * chunkSize;\r\n-      const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n-      const chunk = fileBuffer.slice(start, end);\r\n-      const chunkMd5 = chunk_md5s[i];\r\n+    const formData = new FormData();\r\n+    formData.append(\"file_id\", fileInfo.hash);\r\n+    formData.append(\"index\", i.toString());\r\n+    formData.append(\"chunk\", new Blob([chunk]));\r\n+    formData.append(\"total\", chunkCount.toString());\r\n+    formData.append(\"chunk_md5\", chunkMd5);\r\n \r\n-      const formData = new FormData();\r\n-      formData.append(\"file_id\", fileInfo.hash);\r\n-      formData.append(\"index\", i.toString());\r\n-      formData.append(\"chunk\", new Blob([chunk]));\r\n-      formData.append(\"total\", chunkCount.toString());\r\n-      formData.append(\"chunk_md5\", chunkMd5);\r\n+    await fetch(\"http://localhost:3000/api/file/upload\", {\r\n+      method: \"POST\",\r\n+      body: formData,\r\n+    });\r\n \r\n-      try {\r\n-        await fetch(\"http://localhost:3000/api/file/upload\", {\r\n-          method: \"POST\",\r\n-          body: formData,\r\n-        });\r\n+    self.postMessage({\r\n+      type: \"progress\",\r\n+      progress: Math.round(((i + 1) / chunkCount) * 100),\r\n+    });\r\n+  }\r\n \r\n-        // 更新进度\r\n-        totalUploadedChunks++;\r\n-        const progress = Math.round((totalUploadedChunks / chunkCount) * 100);\r\n-\r\n-        self.postMessage({\r\n-          type: \"progress\",\r\n-          progress: progress,\r\n-          chunkIndex: i,\r\n-          completedChunks: totalUploadedChunks,\r\n-          totalChunks: chunkCount,\r\n-        });\r\n-      } catch (error) {\r\n-        // 处理上传错误\r\n-        console.error(`分片 ${i} 上传失败:`, error);\r\n-        throw error;\r\n-      }\r\n-    };\r\n-  });\r\n-\r\n-  // 将所有上传任务添加到队列\r\n-  const uploadPromises = uploadTasks.map((task) => queue.add(task));\r\n-\r\n-  // 等待所有上传任务完成\r\n-  await Promise.all(uploadPromises);\r\n-\r\n   // 4. 合并\r\n   await fetch(\"http://localhost:3000/api/file/merge\", {\r\n     method: \"POST\",\r\n     headers: { \"Content-Type\": \"application/json\" },\r\n"
                },
                {
                    "date": 1748903920045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,12 +4,55 @@\n declare const SparkMD5: {\r\n   ArrayBuffer: { hash(buf: ArrayBuffer): string };\r\n };\r\n \r\n+// 简单的并发控制函数\r\n+async function runWithConcurrency(\r\n+  tasks: (() => Promise<void>)[],\r\n+  concurrency: number\r\n+): Promise<void> {\r\n+  // 当前运行的任务数\r\n+  let running = 0;\r\n+  // 下一个要执行的任务索引\r\n+  let taskIndex = 0;\r\n+\r\n+  return new Promise((resolve, reject) => {\r\n+    // 启动初始任务\r\n+    const startNext = () => {\r\n+      // 如果所有任务都完成了，解析 Promise\r\n+      if (taskIndex >= tasks.length && running === 0) {\r\n+        resolve();\r\n+        return;\r\n+      }\r\n+\r\n+      // 当有空闲并且还有任务时，启动新任务\r\n+      while (running < concurrency && taskIndex < tasks.length) {\r\n+        const currentTask = tasks[taskIndex++];\r\n+        running++;\r\n+\r\n+        currentTask()\r\n+          .then(() => {\r\n+            running--;\r\n+            startNext(); // 任务完成后，尝试启动下一个任务\r\n+          })\r\n+          .catch(error => {\r\n+            reject(error); // 任何任务失败都会导致整个 Promise 被拒绝\r\n+          });\r\n+      }\r\n+    };\r\n+\r\n+    startNext();\r\n+  });\r\n+}\r\n+\r\n self.onmessage = async (e) => {\r\n-  const { fileInfo, fileBuffer } = e.data;\r\n+  const { fileInfo, fileBuffer, networkParams } = e.data;\r\n   const chunkSize = fileInfo.chunkSize || 1024 * 1024;\r\n   const chunkCount = Math.ceil(fileBuffer.byteLength / chunkSize);\r\n+\r\n+  // 使用网络参数中的分片并发数，如果没有则默认为2\r\n+  const chunkConcurrency = networkParams?.chunkConcurrency || 2;\r\n+\r\n   const chunk_md5s: string[] = [];\r\n   // 1. 计算所有分片的md5\r\n   for (let i = 0; i < chunkCount; i++) {\r\n     const start = i * chunkSize;\r\n@@ -44,34 +87,46 @@\n     )?.exist;\r\n     if (!exist) needUploadChunks.push(i);\r\n   }\r\n \r\n-  // 3. 分片上传\r\n-  for (let i = 0; i < chunkCount; i++) {\r\n-    if (!needUploadChunks.includes(i)) continue;\r\n-    const start = i * chunkSize;\r\n-    const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n-    const chunk = fileBuffer.slice(start, end);\r\n-    const chunkMd5 = chunk_md5s[i];\r\n+  // 记录已完成的分片数量，用于计算进度\r\n+  const completedChunks = chunkCount - needUploadChunks.length;\r\n+  let totalUploadedChunks = completedChunks;\r\n \r\n-    const formData = new FormData();\r\n-    formData.append(\"file_id\", fileInfo.hash);\r\n-    formData.append(\"index\", i.toString());\r\n-    formData.append(\"chunk\", new Blob([chunk]));\r\n-    formData.append(\"total\", chunkCount.toString());\r\n-    formData.append(\"chunk_md5\", chunkMd5);\r\n+  // 3. 分片上传 - 使用并发控制\r\n+  const uploadTasks = needUploadChunks.map(i => {\r\n+    return async () => {\r\n+      const start = i * chunkSize;\r\n+      const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n+      const chunk = fileBuffer.slice(start, end);\r\n+      const chunkMd5 = chunk_md5s[i];\r\n \r\n-    await fetch(\"http://localhost:3000/api/file/upload\", {\r\n-      method: \"POST\",\r\n-      body: formData,\r\n-    });\r\n+      const formData = new FormData();\r\n+      formData.append(\"file_id\", fileInfo.hash);\r\n+      formData.append(\"index\", i.toString());\r\n+      formData.append(\"chunk\", new Blob([chunk]));\r\n+      formData.append(\"total\", chunkCount.toString());\r\n+      formData.append(\"chunk_md5\", chunkMd5);\r\n \r\n-    self.postMessage({\r\n-      type: \"progress\",\r\n-      progress: Math.round(((i + 1) / chunkCount) * 100),\r\n-    });\r\n-  }\r\n+      await fetch(\"http://localhost:3000/api/file/upload\", {\r\n+        method: \"POST\",\r\n+        body: formData,\r\n+      });\r\n \r\n+      // 更新进度\r\n+      totalUploadedChunks++;\r\n+      const progress = Math.round((totalUploadedChunks / chunkCount) * 100);\r\n+\r\n+      self.postMessage({\r\n+        type: \"progress\",\r\n+        progress: progress,\r\n+      });\r\n+    };\r\n+  });\r\n+\r\n+  // 使用并发控制函数执行上传任务\r\n+  await runWithConcurrency(uploadTasks, chunkConcurrency);\r\n+\r\n   // 4. 合并\r\n   await fetch(\"http://localhost:3000/api/file/merge\", {\r\n     method: \"POST\",\r\n     headers: { \"Content-Type\": \"application/json\" },\r\n"
                },
                {
                    "date": 1748903982893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n           .then(() => {\r\n             running--;\r\n             startNext(); // 任务完成后，尝试启动下一个任务\r\n           })\r\n-          .catch(error => {\r\n+          .catch((error) => {\r\n             reject(error); // 任何任务失败都会导致整个 Promise 被拒绝\r\n           });\r\n       }\r\n     };\r\n@@ -92,9 +92,9 @@\n   const completedChunks = chunkCount - needUploadChunks.length;\r\n   let totalUploadedChunks = completedChunks;\r\n \r\n   // 3. 分片上传 - 使用并发控制\r\n-  const uploadTasks = needUploadChunks.map(i => {\r\n+  const uploadTasks = needUploadChunks.map((i) => {\r\n     return async () => {\r\n       const start = i * chunkSize;\r\n       const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n       const chunk = fileBuffer.slice(start, end);\r\n"
                },
                {
                    "date": 1748904336324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,45 +4,69 @@\n declare const SparkMD5: {\r\n   ArrayBuffer: { hash(buf: ArrayBuffer): string };\r\n };\r\n \r\n-// 简单的并发控制函数\r\n-async function runWithConcurrency(\r\n-  tasks: (() => Promise<void>)[],\r\n-  concurrency: number\r\n-): Promise<void> {\r\n-  // 当前运行的任务数\r\n-  let running = 0;\r\n-  // 下一个要执行的任务索引\r\n-  let taskIndex = 0;\r\n+/**\r\n+ * 简化版的 p-queue 实现，用于并发控制\r\n+ */\r\n+class PQueue {\r\n+  private concurrency: number;\r\n+  private running = 0;\r\n+  private queue: Array<() => Promise<unknown>> = [];\r\n+  private resolvers: Map<number, () => void> = new Map();\r\n+  private taskId = 0;\r\n \r\n-  return new Promise((resolve, reject) => {\r\n-    // 启动初始任务\r\n-    const startNext = () => {\r\n-      // 如果所有任务都完成了，解析 Promise\r\n-      if (taskIndex >= tasks.length && running === 0) {\r\n-        resolve();\r\n-        return;\r\n-      }\r\n+  constructor(options: { concurrency: number }) {\r\n+    this.concurrency = options.concurrency;\r\n+  }\r\n \r\n-      // 当有空闲并且还有任务时，启动新任务\r\n-      while (running < concurrency && taskIndex < tasks.length) {\r\n-        const currentTask = tasks[taskIndex++];\r\n-        running++;\r\n+  add<T>(fn: () => Promise<T>): Promise<T> {\r\n+    return new Promise<T>((resolve, reject) => {\r\n+      const id = this.taskId++;\r\n+      const run = async () => {\r\n+        this.running++;\r\n \r\n-        currentTask()\r\n-          .then(() => {\r\n-            running--;\r\n-            startNext(); // 任务完成后，尝试启动下一个任务\r\n-          })\r\n-          .catch((error) => {\r\n-            reject(error); // 任何任务失败都会导致整个 Promise 被拒绝\r\n-          });\r\n+        try {\r\n+          const result = await fn();\r\n+          resolve(result);\r\n+        } catch (error) {\r\n+          reject(error);\r\n+        } finally {\r\n+          this.running--;\r\n+          this.resolvers.delete(id);\r\n+          this.processQueue();\r\n+        }\r\n+      };\r\n+\r\n+      if (this.running < this.concurrency) {\r\n+        // 如果没有达到并发限制，直接运行\r\n+        run();\r\n+      } else {\r\n+        // 否则加入队列\r\n+        this.queue.push(run);\r\n+        this.resolvers.set(id, run);\r\n       }\r\n-    };\r\n+    });\r\n+  }\r\n \r\n-    startNext();\r\n-  });\r\n+  private processQueue() {\r\n+    if (this.queue.length > 0 && this.running < this.concurrency) {\r\n+      const task = this.queue.shift();\r\n+      if (task) {\r\n+        task();\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  // 获取当前排队任务数\r\n+  get size() {\r\n+    return this.queue.length;\r\n+  }\r\n+\r\n+  // 获取当前正在执行的任务数\r\n+  get pending() {\r\n+    return this.running;\r\n+  }\r\n }\r\n \r\n self.onmessage = async (e) => {\r\n   const { fileInfo, fileBuffer, networkParams } = e.data;\r\n@@ -51,8 +75,11 @@\n \r\n   // 使用网络参数中的分片并发数，如果没有则默认为2\r\n   const chunkConcurrency = networkParams?.chunkConcurrency || 2;\r\n \r\n+  // 创建队列，限制并发请求数\r\n+  const queue = new PQueue({ concurrency: chunkConcurrency });\r\n+\r\n   const chunk_md5s: string[] = [];\r\n   // 1. 计算所有分片的md5\r\n   for (let i = 0; i < chunkCount; i++) {\r\n     const start = i * chunkSize;\r\n@@ -91,10 +118,10 @@\n   // 记录已完成的分片数量，用于计算进度\r\n   const completedChunks = chunkCount - needUploadChunks.length;\r\n   let totalUploadedChunks = completedChunks;\r\n \r\n-  // 3. 分片上传 - 使用并发控制\r\n-  const uploadTasks = needUploadChunks.map((i) => {\r\n+  // 3. 分片上传 - 使用 p-queue 进行并发控制\r\n+  const uploadTasks = needUploadChunks.map(i => {\r\n     return async () => {\r\n       const start = i * chunkSize;\r\n       const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n       const chunk = fileBuffer.slice(start, end);\r\n@@ -118,15 +145,21 @@\n \r\n       self.postMessage({\r\n         type: \"progress\",\r\n         progress: progress,\r\n+        chunkIndex: i,\r\n+        completedChunks: totalUploadedChunks,\r\n+        totalChunks: chunkCount,\r\n       });\r\n     };\r\n   });\r\n \r\n-  // 使用并发控制函数执行上传任务\r\n-  await runWithConcurrency(uploadTasks, chunkConcurrency);\r\n+  // 将所有上传任务添加到队列\r\n+  const uploadPromises = uploadTasks.map(task => queue.add(task));\r\n \r\n+  // 等待所有上传任务完成\r\n+  await Promise.all(uploadPromises);\r\n+\r\n   // 4. 合并\r\n   await fetch(\"http://localhost:3000/api/file/merge\", {\r\n     method: \"POST\",\r\n     headers: { \"Content-Type\": \"application/json\" },\r\n"
                },
                {
                    "date": 1748904368673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,69 +4,45 @@\n declare const SparkMD5: {\r\n   ArrayBuffer: { hash(buf: ArrayBuffer): string };\r\n };\r\n \r\n-/**\r\n- * 简化版的 p-queue 实现，用于并发控制\r\n- */\r\n-class PQueue {\r\n-  private concurrency: number;\r\n-  private running = 0;\r\n-  private queue: Array<() => Promise<unknown>> = [];\r\n-  private resolvers: Map<number, () => void> = new Map();\r\n-  private taskId = 0;\r\n+// 简单的并发控制函数\r\n+async function runWithConcurrency(\r\n+  tasks: (() => Promise<void>)[],\r\n+  concurrency: number\r\n+): Promise<void> {\r\n+  // 当前运行的任务数\r\n+  let running = 0;\r\n+  // 下一个要执行的任务索引\r\n+  let taskIndex = 0;\r\n \r\n-  constructor(options: { concurrency: number }) {\r\n-    this.concurrency = options.concurrency;\r\n-  }\r\n+  return new Promise((resolve, reject) => {\r\n+    // 启动初始任务\r\n+    const startNext = () => {\r\n+      // 如果所有任务都完成了，解析 Promise\r\n+      if (taskIndex >= tasks.length && running === 0) {\r\n+        resolve();\r\n+        return;\r\n+      }\r\n \r\n-  add<T>(fn: () => Promise<T>): Promise<T> {\r\n-    return new Promise<T>((resolve, reject) => {\r\n-      const id = this.taskId++;\r\n-      const run = async () => {\r\n-        this.running++;\r\n+      // 当有空闲并且还有任务时，启动新任务\r\n+      while (running < concurrency && taskIndex < tasks.length) {\r\n+        const currentTask = tasks[taskIndex++];\r\n+        running++;\r\n \r\n-        try {\r\n-          const result = await fn();\r\n-          resolve(result);\r\n-        } catch (error) {\r\n-          reject(error);\r\n-        } finally {\r\n-          this.running--;\r\n-          this.resolvers.delete(id);\r\n-          this.processQueue();\r\n-        }\r\n-      };\r\n-\r\n-      if (this.running < this.concurrency) {\r\n-        // 如果没有达到并发限制，直接运行\r\n-        run();\r\n-      } else {\r\n-        // 否则加入队列\r\n-        this.queue.push(run);\r\n-        this.resolvers.set(id, run);\r\n+        currentTask()\r\n+          .then(() => {\r\n+            running--;\r\n+            startNext(); // 任务完成后，尝试启动下一个任务\r\n+          })\r\n+          .catch((error) => {\r\n+            reject(error); // 任何任务失败都会导致整个 Promise 被拒绝\r\n+          });\r\n       }\r\n-    });\r\n-  }\r\n+    };\r\n \r\n-  private processQueue() {\r\n-    if (this.queue.length > 0 && this.running < this.concurrency) {\r\n-      const task = this.queue.shift();\r\n-      if (task) {\r\n-        task();\r\n-      }\r\n-    }\r\n-  }\r\n-\r\n-  // 获取当前排队任务数\r\n-  get size() {\r\n-    return this.queue.length;\r\n-  }\r\n-\r\n-  // 获取当前正在执行的任务数\r\n-  get pending() {\r\n-    return this.running;\r\n-  }\r\n+    startNext();\r\n+  });\r\n }\r\n \r\n self.onmessage = async (e) => {\r\n   const { fileInfo, fileBuffer, networkParams } = e.data;\r\n@@ -75,11 +51,8 @@\n \r\n   // 使用网络参数中的分片并发数，如果没有则默认为2\r\n   const chunkConcurrency = networkParams?.chunkConcurrency || 2;\r\n \r\n-  // 创建队列，限制并发请求数\r\n-  const queue = new PQueue({ concurrency: chunkConcurrency });\r\n-\r\n   const chunk_md5s: string[] = [];\r\n   // 1. 计算所有分片的md5\r\n   for (let i = 0; i < chunkCount; i++) {\r\n     const start = i * chunkSize;\r\n@@ -118,9 +91,9 @@\n   // 记录已完成的分片数量，用于计算进度\r\n   const completedChunks = chunkCount - needUploadChunks.length;\r\n   let totalUploadedChunks = completedChunks;\r\n \r\n-  // 3. 分片上传 - 使用 p-queue 进行并发控制\r\n+  // 3. 分片上传 - 使用并发控制\r\n   const uploadTasks = needUploadChunks.map((i) => {\r\n     return async () => {\r\n       const start = i * chunkSize;\r\n       const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n@@ -145,21 +118,15 @@\n \r\n       self.postMessage({\r\n         type: \"progress\",\r\n         progress: progress,\r\n-        chunkIndex: i,\r\n-        completedChunks: totalUploadedChunks,\r\n-        totalChunks: chunkCount,\r\n       });\r\n     };\r\n   });\r\n \r\n-  // 将所有上传任务添加到队列\r\n-  const uploadPromises = uploadTasks.map((task) => queue.add(task));\r\n+  // 使用并发控制函数执行上传任务\r\n+  await runWithConcurrency(uploadTasks, chunkConcurrency);\r\n \r\n-  // 等待所有上传任务完成\r\n-  await Promise.all(uploadPromises);\r\n-\r\n   // 4. 合并\r\n   await fetch(\"http://localhost:3000/api/file/merge\", {\r\n     method: \"POST\",\r\n     headers: { \"Content-Type\": \"application/json\" },\r\n"
                },
                {
                    "date": 1748904507772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,55 +4,174 @@\n declare const SparkMD5: {\r\n   ArrayBuffer: { hash(buf: ArrayBuffer): string };\r\n };\r\n \r\n-// 简单的并发控制函数\r\n-async function runWithConcurrency(\r\n-  tasks: (() => Promise<void>)[],\r\n-  concurrency: number\r\n-): Promise<void> {\r\n-  // 当前运行的任务数\r\n-  let running = 0;\r\n-  // 下一个要执行的任务索引\r\n-  let taskIndex = 0;\r\n+/**\r\n+ * 内联 p-queue 和其依赖\r\n+ */\r\n \r\n-  return new Promise((resolve, reject) => {\r\n-    // 启动初始任务\r\n-    const startNext = () => {\r\n-      // 如果所有任务都完成了，解析 Promise\r\n-      if (taskIndex >= tasks.length && running === 0) {\r\n-        resolve();\r\n-        return;\r\n-      }\r\n+// 简化版的 EventEmitter\r\n+class EventEmitter {\r\n+  private events: Record<string, Function[]> = {};\r\n \r\n-      // 当有空闲并且还有任务时，启动新任务\r\n-      while (running < concurrency && taskIndex < tasks.length) {\r\n-        const currentTask = tasks[taskIndex++];\r\n-        running++;\r\n+  on(event: string, listener: Function) {\r\n+    if (!this.events[event]) {\r\n+      this.events[event] = [];\r\n+    }\r\n+    this.events[event].push(listener);\r\n+    return this;\r\n+  }\r\n \r\n-        currentTask()\r\n-          .then(() => {\r\n-            running--;\r\n-            startNext(); // 任务完成后，尝试启动下一个任务\r\n-          })\r\n-          .catch((error) => {\r\n-            reject(error); // 任何任务失败都会导致整个 Promise 被拒绝\r\n-          });\r\n+  off(event: string, listener: Function) {\r\n+    if (!this.events[event]) return this;\r\n+    this.events[event] = this.events[event].filter(l => l !== listener);\r\n+    return this;\r\n+  }\r\n+\r\n+  emit(event: string, ...args: any[]) {\r\n+    if (!this.events[event]) return false;\r\n+    this.events[event].forEach(listener => listener(...args));\r\n+    return true;\r\n+  }\r\n+\r\n+  removeAllListeners() {\r\n+    this.events = {};\r\n+    return this;\r\n+  }\r\n+}\r\n+\r\n+// 简化版的 PriorityQueue\r\n+class PriorityQueue {\r\n+  private queue: { priority: number, run: Function, id: string }[] = [];\r\n+\r\n+  enqueue(run: Function, options: { priority?: number, id?: string } = {}) {\r\n+    const priority = options.priority ?? 0;\r\n+    const id = options.id ?? Date.now().toString();\r\n+    this.queue.push({ priority, run, id });\r\n+    this.queue.sort((a, b) => b.priority - a.priority);\r\n+  }\r\n+\r\n+  dequeue() {\r\n+    const item = this.queue.shift();\r\n+    return item?.run;\r\n+  }\r\n+\r\n+  filter(options: { priority?: number, id?: string }) {\r\n+    return this.queue.filter(item => {\r\n+      if (options.priority !== undefined && item.priority !== options.priority) {\r\n+        return false;\r\n       }\r\n-    };\r\n+      if (options.id !== undefined && item.id !== options.id) {\r\n+        return false;\r\n+      }\r\n+      return true;\r\n+    });\r\n+  }\r\n \r\n-    startNext();\r\n-  });\r\n+  setPriority(id: string, priority: number) {\r\n+    const item = this.queue.find(item => item.id === id);\r\n+    if (item) {\r\n+      item.priority = priority;\r\n+      this.queue.sort((a, b) => b.priority - a.priority);\r\n+    }\r\n+  }\r\n+\r\n+  get size() {\r\n+    return this.queue.length;\r\n+  }\r\n }\r\n \r\n+// 简化版的 PQueue\r\n+class PQueue extends EventEmitter {\r\n+  private concurrencyLimit: number;\r\n+  private queue: PriorityQueue;\r\n+  private pending = 0;\r\n+  private isPaused = false;\r\n+\r\n+  constructor(options: { concurrency?: number } = {}) {\r\n+    super();\r\n+    this.concurrencyLimit = options.concurrency || Infinity;\r\n+    this.queue = new PriorityQueue();\r\n+  }\r\n+\r\n+  add<T>(fn: () => Promise<T>, options: { priority?: number, id?: string } = {}): Promise<T> {\r\n+    return new Promise<T>((resolve, reject) => {\r\n+      this.queue.enqueue(async () => {\r\n+        this.pending++;\r\n+        this.emit('active');\r\n+\r\n+        try {\r\n+          const result = await fn();\r\n+          resolve(result);\r\n+          this.emit('completed', result);\r\n+        } catch (error) {\r\n+          reject(error);\r\n+          this.emit('error', error);\r\n+        } finally {\r\n+          this.pending--;\r\n+          this.emit('next');\r\n+          this.tryToStartAnother();\r\n+\r\n+          if (this.pending === 0 && this.queue.size === 0) {\r\n+            this.emit('idle');\r\n+          }\r\n+        }\r\n+      }, options);\r\n+\r\n+      this.emit('add');\r\n+      this.tryToStartAnother();\r\n+    });\r\n+  }\r\n+\r\n+  tryToStartAnother() {\r\n+    if (this.isPaused || this.pending >= this.concurrencyLimit || this.queue.size === 0) {\r\n+      return false;\r\n+    }\r\n+\r\n+    const job = this.queue.dequeue();\r\n+    if (job) {\r\n+      job();\r\n+      return true;\r\n+    }\r\n+\r\n+    return false;\r\n+  }\r\n+\r\n+  start() {\r\n+    this.isPaused = false;\r\n+    while (this.tryToStartAnother()) {}\r\n+    return this;\r\n+  }\r\n+\r\n+  pause() {\r\n+    this.isPaused = true;\r\n+    return this;\r\n+  }\r\n+\r\n+  clear() {\r\n+    this.queue = new PriorityQueue();\r\n+  }\r\n+\r\n+  get size() {\r\n+    return this.queue.size;\r\n+  }\r\n+\r\n+  get pending() {\r\n+    return this.pending;\r\n+  }\r\n+}\r\n+\r\n self.onmessage = async (e) => {\r\n   const { fileInfo, fileBuffer, networkParams } = e.data;\r\n   const chunkSize = fileInfo.chunkSize || 1024 * 1024;\r\n   const chunkCount = Math.ceil(fileBuffer.byteLength / chunkSize);\r\n \r\n   // 使用网络参数中的分片并发数，如果没有则默认为2\r\n   const chunkConcurrency = networkParams?.chunkConcurrency || 2;\r\n \r\n+  // 创建队列，限制并发请求数\r\n+  const queue = new PQueue({ concurrency: chunkConcurrency });\r\n+\r\n   const chunk_md5s: string[] = [];\r\n   // 1. 计算所有分片的md5\r\n   for (let i = 0; i < chunkCount; i++) {\r\n     const start = i * chunkSize;\r\n@@ -91,10 +210,10 @@\n   // 记录已完成的分片数量，用于计算进度\r\n   const completedChunks = chunkCount - needUploadChunks.length;\r\n   let totalUploadedChunks = completedChunks;\r\n \r\n-  // 3. 分片上传 - 使用并发控制\r\n-  const uploadTasks = needUploadChunks.map((i) => {\r\n+  // 3. 分片上传 - 使用 p-queue 进行并发控制\r\n+  const uploadTasks = needUploadChunks.map(i => {\r\n     return async () => {\r\n       const start = i * chunkSize;\r\n       const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n       const chunk = fileBuffer.slice(start, end);\r\n@@ -118,15 +237,21 @@\n \r\n       self.postMessage({\r\n         type: \"progress\",\r\n         progress: progress,\r\n+        chunkIndex: i,\r\n+        completedChunks: totalUploadedChunks,\r\n+        totalChunks: chunkCount,\r\n       });\r\n     };\r\n   });\r\n \r\n-  // 使用并发控制函数执行上传任务\r\n-  await runWithConcurrency(uploadTasks, chunkConcurrency);\r\n+  // 将所有上传任务添加到队列\r\n+  const uploadPromises = uploadTasks.map(task => queue.add(task));\r\n \r\n+  // 等待所有上传任务完成\r\n+  await Promise.all(uploadPromises);\r\n+\r\n   // 4. 合并\r\n   await fetch(\"http://localhost:3000/api/file/merge\", {\r\n     method: \"POST\",\r\n     headers: { \"Content-Type\": \"application/json\" },\r\n"
                }
            ],
            "date": 1748903553797,
            "name": "Commit-0",
            "content": "// @ts-expect-error: self 类型\r\nimportScripts(\"https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js\");\r\nimportScripts(\"https://cdn.jsdelivr.net/npm/p-queue@7.3.4/dist/index.min.js\");\r\n\r\ndeclare const SparkMD5: {\r\n  ArrayBuffer: { hash(buf: ArrayBuffer): string };\r\n};\r\n\r\n// p-queue 类型声明\r\ndeclare const PQueue: {\r\n  new (options?: { concurrency?: number; autoStart?: boolean }): {\r\n    add: <T>(fn: () => Promise<T>) => Promise<T>;\r\n    onIdle: () => Promise<void>;\r\n    size: number;\r\n    pending: number;\r\n  };\r\n};\r\n\r\nself.onmessage = async (e) => {\r\n  const { fileInfo, fileBuffer, networkParams } = e.data;\r\n  const chunkSize = fileInfo.chunkSize || 1024 * 1024;\r\n  const chunkCount = Math.ceil(fileBuffer.byteLength / chunkSize);\r\n\r\n  // 使用网络参数中的分片并发数，如果没有则默认为2\r\n  const chunkConcurrency = networkParams?.chunkConcurrency || 2;\r\n\r\n  // 创建队列，限制并发请求数\r\n  const queue = new PQueue({ concurrency: chunkConcurrency });\r\n\r\n  const chunk_md5s: string[] = [];\r\n  // 1. 计算所有分片的md5\r\n  for (let i = 0; i < chunkCount; i++) {\r\n    const start = i * chunkSize;\r\n    const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n    const chunk = fileBuffer.slice(start, end);\r\n    const chunkMd5 = SparkMD5.ArrayBuffer.hash(chunk);\r\n    chunk_md5s.push(chunkMd5);\r\n  }\r\n\r\n  // 2. 秒传确认\r\n  const instantRes = await fetch(\"http://localhost:3000/api/file/instant\", {\r\n    method: \"POST\",\r\n    headers: { \"Content-Type\": \"application/json\" },\r\n    body: JSON.stringify({\r\n      file_id: fileInfo.hash,\r\n      md5: fileInfo.hash,\r\n      name: fileInfo.fileName,\r\n      size: fileInfo.fileSize,\r\n      total: chunkCount,\r\n      chunk_md5s,\r\n    }),\r\n  });\r\n  const instantData = await instantRes.json();\r\n  if (instantData.data?.uploaded) {\r\n    self.postMessage({ type: \"done\", skipped: true });\r\n    return;\r\n  }\r\n  const needUploadChunks: number[] = [];\r\n  for (let i = 0; i < chunkCount; i++) {\r\n    const exist = instantData.data?.chunkCheckResult?.find(\r\n      (c: { index: number; exist: boolean }) => c.index === i\r\n    )?.exist;\r\n    if (!exist) needUploadChunks.push(i);\r\n  }\r\n\r\n  // 记录已完成的分片数量，用于计算进度\r\n  let completedChunks = chunkCount - needUploadChunks.length;\r\n  let totalUploadedChunks = completedChunks;\r\n\r\n  // 3. 分片上传 - 使用 p-queue 进行并发控制\r\n  const uploadTasks = needUploadChunks.map((i) => {\r\n    return async () => {\r\n      const start = i * chunkSize;\r\n      const end = Math.min(fileBuffer.byteLength, start + chunkSize);\r\n      const chunk = fileBuffer.slice(start, end);\r\n      const chunkMd5 = chunk_md5s[i];\r\n\r\n      const formData = new FormData();\r\n      formData.append(\"file_id\", fileInfo.hash);\r\n      formData.append(\"index\", i.toString());\r\n      formData.append(\"chunk\", new Blob([chunk]));\r\n      formData.append(\"total\", chunkCount.toString());\r\n      formData.append(\"chunk_md5\", chunkMd5);\r\n\r\n      try {\r\n        await fetch(\"http://localhost:3000/api/file/upload\", {\r\n          method: \"POST\",\r\n          body: formData,\r\n        });\r\n\r\n        // 更新进度\r\n        totalUploadedChunks++;\r\n        const progress = Math.round((totalUploadedChunks / chunkCount) * 100);\r\n\r\n        self.postMessage({\r\n          type: \"progress\",\r\n          progress: progress,\r\n          chunkIndex: i,\r\n          completedChunks: totalUploadedChunks,\r\n          totalChunks: chunkCount,\r\n        });\r\n      } catch (error) {\r\n        // 处理上传错误\r\n        console.error(`分片 ${i} 上传失败:`, error);\r\n        throw error;\r\n      }\r\n    };\r\n  });\r\n\r\n  // 将所有上传任务添加到队列\r\n  const uploadPromises = uploadTasks.map((task) => queue.add(task));\r\n\r\n  // 等待所有上传任务完成\r\n  await Promise.all(uploadPromises);\r\n\r\n  // 4. 合并\r\n  await fetch(\"http://localhost:3000/api/file/merge\", {\r\n    method: \"POST\",\r\n    headers: { \"Content-Type\": \"application/json\" },\r\n    body: JSON.stringify({\r\n      file_id: fileInfo.hash,\r\n      md5: fileInfo.hash,\r\n      name: fileInfo.fileName,\r\n      size: fileInfo.fileSize,\r\n      total: chunkCount,\r\n    }),\r\n  });\r\n\r\n  self.postMessage({ type: \"done\" });\r\n};\r\n"
        }
    ]
}