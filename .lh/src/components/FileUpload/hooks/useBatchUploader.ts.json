{
    "sourceFile": "src/components/FileUpload/hooks/useBatchUploader.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1748871850520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748877499101,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import { UploadFile, UploadStatus } from \"../../../types/upload\";\r\n+import { UploadFile, UploadStatus } from \"../types/upload\";\r\n \r\n import localforage from \"localforage\";\r\n import { useState } from \"react\";\r\n \r\n"
                },
                {
                    "date": 1748877590858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,62 +4,163 @@\n import { useState } from \"react\";\r\n \r\n const workerUrl = new URL(\"../worker/uploadWorker.ts\", import.meta.url).href;\r\n \r\n-interface UseBatchUploaderOptions {\r\n+export interface BatchInfo {\r\n+  current: number;\r\n+  total: number;\r\n+}\r\n+\r\n+export interface WorkerProgressMessage {\r\n+  type: \"progress\";\r\n+  progress: number;\r\n+  fileId: string;\r\n+  processed?: number;\r\n+  success?: number;\r\n+  failed?: number;\r\n+  oversized?: number;\r\n+}\r\n+\r\n+export interface WorkerDoneMessage {\r\n+  type: \"done\";\r\n+  fileId: string;\r\n+  skipped: boolean;\r\n+}\r\n+\r\n+export type WorkerMessage = WorkerProgressMessage | WorkerDoneMessage;\r\n+\r\n+export interface UseBatchUploaderOptions {\r\n   setProgressMap?: React.Dispatch<React.SetStateAction<Record<string, number>>>;\r\n-  refreshFiles?: () => void;\r\n+  refreshFiles?: () => Promise<void> | void;\r\n }\r\n \r\n-export function useBatchUploader(options?: UseBatchUploaderOptions) {\r\n-  const [batchInfo, setBatchInfo] = useState<{\r\n-    current: number;\r\n-    total: number;\r\n-  } | null>(null);\r\n+export interface UseBatchUploaderResult {\r\n+  uploadAll: () => Promise<void>;\r\n+  batchInfo: BatchInfo | null;\r\n+  isUploading: boolean;\r\n+  cancelUpload: () => void;\r\n+}\r\n \r\n-  const uploadAll = async () => {\r\n-    const keys = await localforage.keys();\r\n-    setBatchInfo({ current: 0, total: keys.length });\r\n-    for (let i = 0; i < keys.length; i++) {\r\n-      const data = await localforage.getItem<UploadFile>(keys[i]);\r\n-      if (!data || !data.buffer) continue;\r\n-      if (options?.setProgressMap)\r\n-        options.setProgressMap((prev) => ({ ...prev, [data.id]: 0 }));\r\n-      // 上传前，状态设为 UPLOADING\r\n-      await localforage.setItem(data.id, {\r\n-        ...data,\r\n-        status: UploadStatus.UPLOADING,\r\n-      });\r\n-      if (options?.refreshFiles) options.refreshFiles();\r\n-      await new Promise<void>((resolve) => {\r\n-        const worker = new Worker(workerUrl);\r\n-        worker.postMessage({ fileInfo: data, fileBuffer: data.buffer });\r\n-        worker.onmessage = async (e) => {\r\n-          if (e.data.type === \"progress\") {\r\n-            if (options?.setProgressMap)\r\n-              options.setProgressMap((prev) => ({\r\n-                ...prev,\r\n-                [data.id]: e.data.progress,\r\n-              }));\r\n-          } else if (e.data.type === \"done\") {\r\n-            if (options?.setProgressMap)\r\n-              options.setProgressMap((prev) => ({ ...prev, [data.id]: 100 }));\r\n-            // 上传完成或秒传，状态设为 DONE 或 INSTANT\r\n-            const newStatus = e.data.skipped\r\n-              ? UploadStatus.INSTANT\r\n-              : UploadStatus.DONE;\r\n-            await localforage.setItem(data.id, { ...data, status: newStatus });\r\n-            if (options?.refreshFiles) options.refreshFiles();\r\n-            resolve();\r\n-          }\r\n-        };\r\n-      });\r\n-      setBatchInfo({ current: i + 1, total: keys.length });\r\n+export function useBatchUploader(options?: UseBatchUploaderOptions): UseBatchUploaderResult {\r\n+  const [batchInfo, setBatchInfo] = useState<BatchInfo | null>(null);\r\n+  const [isUploading, setIsUploading] = useState<boolean>(false);\r\n+  const [worker, setWorker] = useState<Worker | null>(null);\r\n+\r\n+  const cancelUpload = () => {\r\n+    if (worker) {\r\n+      worker.terminate();\r\n+      setWorker(null);\r\n+      setIsUploading(false);\r\n+      setBatchInfo(null);\r\n     }\r\n-    setBatchInfo(null);\r\n   };\r\n \r\n+  const uploadAll = async (): Promise<void> => {\r\n+    try {\r\n+      setIsUploading(true);\r\n+      const keys = await localforage.keys();\r\n+\r\n+      // 过滤出可上传的文件（排除已完成和秒传的）\r\n+      const uploadableFiles: UploadFile[] = [];\r\n+      for (const key of keys) {\r\n+        const file = await localforage.getItem<UploadFile>(key);\r\n+        if (file && file.buffer &&\r\n+            file.status !== UploadStatus.DONE &&\r\n+            file.status !== UploadStatus.INSTANT) {\r\n+          uploadableFiles.push(file);\r\n+        }\r\n+      }\r\n+\r\n+      if (uploadableFiles.length === 0) {\r\n+        setIsUploading(false);\r\n+        return;\r\n+      }\r\n+\r\n+      setBatchInfo({ current: 0, total: uploadableFiles.length });\r\n+\r\n+      for (let i = 0; i < uploadableFiles.length; i++) {\r\n+        const data = uploadableFiles[i];\r\n+\r\n+        if (options?.setProgressMap) {\r\n+          options.setProgressMap((prev) => ({ ...prev, [data.id]: 0 }));\r\n+        }\r\n+\r\n+        // 上传前，状态设为 UPLOADING\r\n+        await localforage.setItem(data.id, {\r\n+          ...data,\r\n+          status: UploadStatus.UPLOADING,\r\n+        });\r\n+\r\n+        if (options?.refreshFiles) {\r\n+          await options.refreshFiles();\r\n+        }\r\n+\r\n+        await new Promise<void>((resolve, reject) => {\r\n+          const newWorker = new Worker(workerUrl);\r\n+          setWorker(newWorker);\r\n+\r\n+          newWorker.postMessage({\r\n+            fileInfo: data,\r\n+            fileBuffer: data.buffer\r\n+          });\r\n+\r\n+          newWorker.onmessage = async (e: MessageEvent<WorkerMessage>) => {\r\n+            const message = e.data;\r\n+\r\n+            if (message.type === \"progress\") {\r\n+              if (options?.setProgressMap) {\r\n+                options.setProgressMap((prev) => ({\r\n+                  ...prev,\r\n+                  [data.id]: message.progress,\r\n+                }));\r\n+              }\r\n+            } else if (message.type === \"done\") {\r\n+              if (options?.setProgressMap) {\r\n+                options.setProgressMap((prev) => ({\r\n+                  ...prev,\r\n+                  [data.id]: 100\r\n+                }));\r\n+              }\r\n+\r\n+              // 上传完成或秒传，状态设为 DONE 或 INSTANT\r\n+              const newStatus = message.skipped\r\n+                ? UploadStatus.INSTANT\r\n+                : UploadStatus.DONE;\r\n+\r\n+              await localforage.setItem(data.id, {\r\n+                ...data,\r\n+                status: newStatus\r\n+              });\r\n+\r\n+              if (options?.refreshFiles) {\r\n+                await options.refreshFiles();\r\n+              }\r\n+\r\n+              resolve();\r\n+            }\r\n+          };\r\n+\r\n+          newWorker.onerror = (error) => {\r\n+            console.error(\"Worker error:\", error);\r\n+            reject(error);\r\n+          };\r\n+        });\r\n+\r\n+        setBatchInfo({ current: i + 1, total: uploadableFiles.length });\r\n+      }\r\n+    } catch (error) {\r\n+      console.error(\"Upload error:\", error);\r\n+      // 处理错误状态\r\n+    } finally {\r\n+      setWorker(null);\r\n+      setIsUploading(false);\r\n+      setBatchInfo(null);\r\n+    }\r\n+  };\r\n+\r\n   return {\r\n     uploadAll,\r\n     batchInfo,\r\n+    isUploading,\r\n+    cancelUpload\r\n   };\r\n }\r\n"
                },
                {
                    "date": 1748877686770,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,168 +4,62 @@\n import { useState } from \"react\";\r\n \r\n const workerUrl = new URL(\"../worker/uploadWorker.ts\", import.meta.url).href;\r\n \r\n-export interface BatchInfo {\r\n-  current: number;\r\n-  total: number;\r\n-}\r\n-\r\n-export interface WorkerProgressMessage {\r\n-  type: \"progress\";\r\n-  progress: number;\r\n-  fileId: string;\r\n-  processed?: number;\r\n-  success?: number;\r\n-  failed?: number;\r\n-  oversized?: number;\r\n-}\r\n-\r\n-export interface WorkerDoneMessage {\r\n-  type: \"done\";\r\n-  fileId: string;\r\n-  skipped: boolean;\r\n-}\r\n-\r\n-export type WorkerMessage = WorkerProgressMessage | WorkerDoneMessage;\r\n-\r\n-export interface UseBatchUploaderOptions {\r\n+interface UseBatchUploaderOptions {\r\n   setProgressMap?: React.Dispatch<React.SetStateAction<Record<string, number>>>;\r\n-  refreshFiles?: () => Promise<void> | void;\r\n+  refreshFiles?: () => void;\r\n }\r\n \r\n-export interface UseBatchUploaderResult {\r\n-  uploadAll: () => Promise<void>;\r\n-  batchInfo: BatchInfo | null;\r\n-  isUploading: boolean;\r\n-  cancelUpload: () => void;\r\n-}\r\n+export function useBatchUploader(options?: UseBatchUploaderOptions) {\r\n+  const [batchInfo, setBatchInfo] = useState<{\r\n+    current: number;\r\n+    total: number;\r\n+  } | null>(null);\r\n \r\n-export function useBatchUploader(\r\n-  options?: UseBatchUploaderOptions\r\n-): UseBatchUploaderResult {\r\n-  const [batchInfo, setBatchInfo] = useState<BatchInfo | null>(null);\r\n-  const [isUploading, setIsUploading] = useState<boolean>(false);\r\n-  const [worker, setWorker] = useState<Worker | null>(null);\r\n-\r\n-  const cancelUpload = () => {\r\n-    if (worker) {\r\n-      worker.terminate();\r\n-      setWorker(null);\r\n-      setIsUploading(false);\r\n-      setBatchInfo(null);\r\n+  const uploadAll = async () => {\r\n+    const keys = await localforage.keys();\r\n+    setBatchInfo({ current: 0, total: keys.length });\r\n+    for (let i = 0; i < keys.length; i++) {\r\n+      const data = await localforage.getItem<UploadFile>(keys[i]);\r\n+      if (!data || !data.buffer) continue;\r\n+      if (options?.setProgressMap)\r\n+        options.setProgressMap((prev) => ({ ...prev, [data.id]: 0 }));\r\n+      // 上传前，状态设为 UPLOADING\r\n+      await localforage.setItem(data.id, {\r\n+        ...data,\r\n+        status: UploadStatus.UPLOADING,\r\n+      });\r\n+      if (options?.refreshFiles) options.refreshFiles();\r\n+      await new Promise<void>((resolve) => {\r\n+        const worker = new Worker(workerUrl);\r\n+        worker.postMessage({ fileInfo: data, fileBuffer: data.buffer });\r\n+        worker.onmessage = async (e) => {\r\n+          if (e.data.type === \"progress\") {\r\n+            if (options?.setProgressMap)\r\n+              options.setProgressMap((prev) => ({\r\n+                ...prev,\r\n+                [data.id]: e.data.progress,\r\n+              }));\r\n+          } else if (e.data.type === \"done\") {\r\n+            if (options?.setProgressMap)\r\n+              options.setProgressMap((prev) => ({ ...prev, [data.id]: 100 }));\r\n+            // 上传完成或秒传，状态设为 DONE 或 INSTANT\r\n+            const newStatus = e.data.skipped\r\n+              ? UploadStatus.INSTANT\r\n+              : UploadStatus.DONE;\r\n+            await localforage.setItem(data.id, { ...data, status: newStatus });\r\n+            if (options?.refreshFiles) options.refreshFiles();\r\n+            resolve();\r\n+          }\r\n+        };\r\n+      });\r\n+      setBatchInfo({ current: i + 1, total: keys.length });\r\n     }\r\n+    setBatchInfo(null);\r\n   };\r\n \r\n-  const uploadAll = async (): Promise<void> => {\r\n-    try {\r\n-      setIsUploading(true);\r\n-      const keys = await localforage.keys();\r\n-\r\n-      // 过滤出可上传的文件（排除已完成和秒传的）\r\n-      const uploadableFiles: UploadFile[] = [];\r\n-      for (const key of keys) {\r\n-        const file = await localforage.getItem<UploadFile>(key);\r\n-        if (\r\n-          file &&\r\n-          file.buffer &&\r\n-          file.status !== UploadStatus.DONE &&\r\n-          file.status !== UploadStatus.INSTANT\r\n-        ) {\r\n-          uploadableFiles.push(file);\r\n-        }\r\n-      }\r\n-\r\n-      if (uploadableFiles.length === 0) {\r\n-        setIsUploading(false);\r\n-        return;\r\n-      }\r\n-\r\n-      setBatchInfo({ current: 0, total: uploadableFiles.length });\r\n-\r\n-      for (let i = 0; i < uploadableFiles.length; i++) {\r\n-        const data = uploadableFiles[i];\r\n-\r\n-        if (options?.setProgressMap) {\r\n-          options.setProgressMap((prev) => ({ ...prev, [data.id]: 0 }));\r\n-        }\r\n-\r\n-        // 上传前，状态设为 UPLOADING\r\n-        await localforage.setItem(data.id, {\r\n-          ...data,\r\n-          status: UploadStatus.UPLOADING,\r\n-        });\r\n-\r\n-        if (options?.refreshFiles) {\r\n-          await options.refreshFiles();\r\n-        }\r\n-\r\n-        await new Promise<void>((resolve, reject) => {\r\n-          const newWorker = new Worker(workerUrl);\r\n-          setWorker(newWorker);\r\n-\r\n-          newWorker.postMessage({\r\n-            fileInfo: data,\r\n-            fileBuffer: data.buffer,\r\n-          });\r\n-\r\n-          newWorker.onmessage = async (e: MessageEvent<WorkerMessage>) => {\r\n-            const message = e.data;\r\n-\r\n-            if (message.type === \"progress\") {\r\n-              if (options?.setProgressMap) {\r\n-                options.setProgressMap((prev) => ({\r\n-                  ...prev,\r\n-                  [data.id]: message.progress,\r\n-                }));\r\n-              }\r\n-            } else if (message.type === \"done\") {\r\n-              if (options?.setProgressMap) {\r\n-                options.setProgressMap((prev) => ({\r\n-                  ...prev,\r\n-                  [data.id]: 100,\r\n-                }));\r\n-              }\r\n-\r\n-              // 上传完成或秒传，状态设为 DONE 或 INSTANT\r\n-              const newStatus = message.skipped\r\n-                ? UploadStatus.INSTANT\r\n-                : UploadStatus.DONE;\r\n-\r\n-              await localforage.setItem(data.id, {\r\n-                ...data,\r\n-                status: newStatus,\r\n-              });\r\n-\r\n-              if (options?.refreshFiles) {\r\n-                await options.refreshFiles();\r\n-              }\r\n-\r\n-              resolve();\r\n-            }\r\n-          };\r\n-\r\n-          newWorker.onerror = (error) => {\r\n-            console.error(\"Worker error:\", error);\r\n-            reject(error);\r\n-          };\r\n-        });\r\n-\r\n-        setBatchInfo({ current: i + 1, total: uploadableFiles.length });\r\n-      }\r\n-    } catch (error) {\r\n-      console.error(\"Upload error:\", error);\r\n-      // 处理错误状态\r\n-    } finally {\r\n-      setWorker(null);\r\n-      setIsUploading(false);\r\n-      setBatchInfo(null);\r\n-    }\r\n-  };\r\n-\r\n   return {\r\n     uploadAll,\r\n     batchInfo,\r\n-    isUploading,\r\n-    cancelUpload,\r\n   };\r\n }\r\n"
                },
                {
                    "date": 1748901567462,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,65 +1,232 @@\n import { UploadFile, UploadStatus } from \"../types/upload\";\r\n+import { useCallback, useEffect, useRef, useState } from \"react\";\r\n \r\n+import PQueue from \"p-queue\";\r\n import localforage from \"localforage\";\r\n-import { useState } from \"react\";\r\n \r\n const workerUrl = new URL(\"../worker/uploadWorker.ts\", import.meta.url).href;\r\n \r\n interface UseBatchUploaderOptions {\r\n   setProgressMap?: React.Dispatch<React.SetStateAction<Record<string, number>>>;\r\n   refreshFiles?: () => void;\r\n+  fileConcurrency?: number; // 并发上传文件数\r\n }\r\n \r\n export function useBatchUploader(options?: UseBatchUploaderOptions) {\r\n   const [batchInfo, setBatchInfo] = useState<{\r\n     current: number;\r\n     total: number;\r\n+    queued: number;\r\n+    active: number;\r\n+    completed: number;\r\n+    failed: number;\r\n   } | null>(null);\r\n \r\n-  const uploadAll = async () => {\r\n-    const keys = await localforage.keys();\r\n-    setBatchInfo({ current: 0, total: keys.length });\r\n-    for (let i = 0; i < keys.length; i++) {\r\n-      const data = await localforage.getItem<UploadFile>(keys[i]);\r\n-      if (!data || !data.buffer) continue;\r\n-      if (options?.setProgressMap)\r\n-        options.setProgressMap((prev) => ({ ...prev, [data.id]: 0 }));\r\n+  const [isUploading, setIsUploading] = useState(false);\r\n+  const queueRef = useRef<PQueue | null>(null);\r\n+  const cancelTokenRef = useRef<AbortController | null>(null);\r\n+\r\n+  // 初始化队列或当并发数变更时更新队列配置\r\n+  useEffect(() => {\r\n+    if (!queueRef.current) {\r\n+      queueRef.current = new PQueue({\r\n+        concurrency: options?.fileConcurrency || 2,\r\n+        autoStart: true\r\n+      });\r\n+    } else if (options?.fileConcurrency) {\r\n+      queueRef.current.concurrency = options.fileConcurrency;\r\n+    }\r\n+\r\n+    return () => {\r\n+      if (queueRef.current) {\r\n+        queueRef.current.clear();\r\n+      }\r\n+    };\r\n+  }, [options?.fileConcurrency]);\r\n+\r\n+  // 取消所有上传任务\r\n+  const cancelUpload = useCallback(() => {\r\n+    if (queueRef.current) {\r\n+      queueRef.current.clear();\r\n+      queueRef.current.pause();\r\n+    }\r\n+\r\n+    if (cancelTokenRef.current) {\r\n+      cancelTokenRef.current.abort();\r\n+    }\r\n+\r\n+    setIsUploading(false);\r\n+    setBatchInfo(null);\r\n+  }, []);\r\n+\r\n+  // 上传单个文件的任务\r\n+  const uploadFile = useCallback(async (file: UploadFile) => {\r\n+    if (!file || !file.buffer) return false;\r\n+\r\n+    try {\r\n+      if (options?.setProgressMap) {\r\n+        options.setProgressMap((prev) => ({ ...prev, [file.id]: 0 }));\r\n+      }\r\n+\r\n       // 上传前，状态设为 UPLOADING\r\n-      await localforage.setItem(data.id, {\r\n-        ...data,\r\n+      await localforage.setItem(file.id, {\r\n+        ...file,\r\n         status: UploadStatus.UPLOADING,\r\n       });\r\n-      if (options?.refreshFiles) options.refreshFiles();\r\n-      await new Promise<void>((resolve) => {\r\n+\r\n+      if (options?.refreshFiles) {\r\n+        options.refreshFiles();\r\n+      }\r\n+\r\n+      return await new Promise<boolean>((resolve, reject) => {\r\n         const worker = new Worker(workerUrl);\r\n-        worker.postMessage({ fileInfo: data, fileBuffer: data.buffer });\r\n+        worker.postMessage({ fileInfo: file, fileBuffer: file.buffer });\r\n+\r\n         worker.onmessage = async (e) => {\r\n           if (e.data.type === \"progress\") {\r\n-            if (options?.setProgressMap)\r\n+            if (options?.setProgressMap) {\r\n               options.setProgressMap((prev) => ({\r\n                 ...prev,\r\n-                [data.id]: e.data.progress,\r\n+                [file.id]: e.data.progress,\r\n               }));\r\n+            }\r\n           } else if (e.data.type === \"done\") {\r\n-            if (options?.setProgressMap)\r\n-              options.setProgressMap((prev) => ({ ...prev, [data.id]: 100 }));\r\n+            if (options?.setProgressMap) {\r\n+              options.setProgressMap((prev) => ({ ...prev, [file.id]: 100 }));\r\n+            }\r\n+\r\n             // 上传完成或秒传，状态设为 DONE 或 INSTANT\r\n             const newStatus = e.data.skipped\r\n               ? UploadStatus.INSTANT\r\n               : UploadStatus.DONE;\r\n-            await localforage.setItem(data.id, { ...data, status: newStatus });\r\n-            if (options?.refreshFiles) options.refreshFiles();\r\n-            resolve();\r\n+\r\n+            await localforage.setItem(file.id, { ...file, status: newStatus });\r\n+\r\n+            if (options?.refreshFiles) {\r\n+              options.refreshFiles();\r\n+            }\r\n+\r\n+            worker.terminate();\r\n+            resolve(true);\r\n           }\r\n         };\r\n+\r\n+        worker.onerror = (error) => {\r\n+          console.error(\"Worker error:\", error);\r\n+          reject(error);\r\n+        };\r\n       });\r\n-      setBatchInfo({ current: i + 1, total: keys.length });\r\n+    } catch (error) {\r\n+      console.error(`上传文件失败: ${file.fileName}`, error);\r\n+\r\n+      // 更新文件状态为错误\r\n+      await localforage.setItem(file.id, {\r\n+        ...file,\r\n+        status: UploadStatus.ERROR,\r\n+        errorMessage: error instanceof Error ? error.message : String(error)\r\n+      });\r\n+\r\n+      if (options?.refreshFiles) {\r\n+        options.refreshFiles();\r\n+      }\r\n+\r\n+      return false;\r\n     }\r\n-    setBatchInfo(null);\r\n-  };\r\n+  }, [options]);\r\n \r\n+  // 批量上传所有文件\r\n+  const uploadAll = useCallback(async () => {\r\n+    if (isUploading) return;\r\n+    setIsUploading(true);\r\n+\r\n+    try {\r\n+      // 创建新的中止控制器\r\n+      cancelTokenRef.current = new AbortController();\r\n+\r\n+      // 确保队列已清空并重新启动\r\n+      if (queueRef.current) {\r\n+        queueRef.current.clear();\r\n+        queueRef.current.start();\r\n+      }\r\n+\r\n+      const keys = await localforage.keys();\r\n+      const uploadableFiles: UploadFile[] = [];\r\n+\r\n+      // 获取所有可上传的文件\r\n+      for (const key of keys) {\r\n+        const file = await localforage.getItem<UploadFile>(key);\r\n+        if (file && file.buffer &&\r\n+            file.status !== UploadStatus.DONE &&\r\n+            file.status !== UploadStatus.INSTANT) {\r\n+          uploadableFiles.push(file);\r\n+        }\r\n+      }\r\n+\r\n+      if (uploadableFiles.length === 0) {\r\n+        setIsUploading(false);\r\n+        return;\r\n+      }\r\n+\r\n+      // 初始化批处理信息\r\n+      setBatchInfo({\r\n+        current: 0,\r\n+        total: uploadableFiles.length,\r\n+        queued: uploadableFiles.length,\r\n+        active: 0,\r\n+        completed: 0,\r\n+        failed: 0\r\n+      });\r\n+\r\n+      // 监听队列事件以更新状态\r\n+      queueRef.current?.on('active', () => {\r\n+        setBatchInfo(prev => prev ? {\r\n+          ...prev,\r\n+          active: queueRef.current?.pending || 0,\r\n+          queued: queueRef.current?.size || 0\r\n+        } : null);\r\n+      });\r\n+\r\n+      queueRef.current?.on('completed', () => {\r\n+        setBatchInfo(prev => prev ? {\r\n+          ...prev,\r\n+          completed: prev.completed + 1,\r\n+          current: prev.current + 1\r\n+        } : null);\r\n+      });\r\n+\r\n+      queueRef.current?.on('error', () => {\r\n+        setBatchInfo(prev => prev ? {\r\n+          ...prev,\r\n+          failed: prev.failed + 1,\r\n+          current: prev.current + 1\r\n+        } : null);\r\n+      });\r\n+\r\n+      // 将所有上传任务添加到队列\r\n+      const uploadPromises = uploadableFiles.map(file => {\r\n+        return queueRef.current?.add(() => uploadFile(file));\r\n+      });\r\n+\r\n+      // 等待所有任务完成\r\n+      await Promise.all(uploadPromises);\r\n+\r\n+      // 清理并重置状态\r\n+      if (options?.refreshFiles) {\r\n+        options.refreshFiles();\r\n+      }\r\n+    } catch (error) {\r\n+      console.error(\"批量上传文件失败:\", error);\r\n+    } finally {\r\n+      setIsUploading(false);\r\n+      setBatchInfo(null);\r\n+      cancelTokenRef.current = null;\r\n+    }\r\n+  }, [isUploading, uploadFile, options?.refreshFiles]);\r\n+\r\n   return {\r\n     uploadAll,\r\n     batchInfo,\r\n+    isUploading,\r\n+    cancelUpload\r\n   };\r\n }\r\n"
                }
            ],
            "date": 1748871850520,
            "name": "Commit-0",
            "content": "import { UploadFile, UploadStatus } from \"../../../types/upload\";\r\n\r\nimport localforage from \"localforage\";\r\nimport { useState } from \"react\";\r\n\r\nconst workerUrl = new URL(\"../worker/uploadWorker.ts\", import.meta.url).href;\r\n\r\ninterface UseBatchUploaderOptions {\r\n  setProgressMap?: React.Dispatch<React.SetStateAction<Record<string, number>>>;\r\n  refreshFiles?: () => void;\r\n}\r\n\r\nexport function useBatchUploader(options?: UseBatchUploaderOptions) {\r\n  const [batchInfo, setBatchInfo] = useState<{\r\n    current: number;\r\n    total: number;\r\n  } | null>(null);\r\n\r\n  const uploadAll = async () => {\r\n    const keys = await localforage.keys();\r\n    setBatchInfo({ current: 0, total: keys.length });\r\n    for (let i = 0; i < keys.length; i++) {\r\n      const data = await localforage.getItem<UploadFile>(keys[i]);\r\n      if (!data || !data.buffer) continue;\r\n      if (options?.setProgressMap)\r\n        options.setProgressMap((prev) => ({ ...prev, [data.id]: 0 }));\r\n      // 上传前，状态设为 UPLOADING\r\n      await localforage.setItem(data.id, {\r\n        ...data,\r\n        status: UploadStatus.UPLOADING,\r\n      });\r\n      if (options?.refreshFiles) options.refreshFiles();\r\n      await new Promise<void>((resolve) => {\r\n        const worker = new Worker(workerUrl);\r\n        worker.postMessage({ fileInfo: data, fileBuffer: data.buffer });\r\n        worker.onmessage = async (e) => {\r\n          if (e.data.type === \"progress\") {\r\n            if (options?.setProgressMap)\r\n              options.setProgressMap((prev) => ({\r\n                ...prev,\r\n                [data.id]: e.data.progress,\r\n              }));\r\n          } else if (e.data.type === \"done\") {\r\n            if (options?.setProgressMap)\r\n              options.setProgressMap((prev) => ({ ...prev, [data.id]: 100 }));\r\n            // 上传完成或秒传，状态设为 DONE 或 INSTANT\r\n            const newStatus = e.data.skipped\r\n              ? UploadStatus.INSTANT\r\n              : UploadStatus.DONE;\r\n            await localforage.setItem(data.id, { ...data, status: newStatus });\r\n            if (options?.refreshFiles) options.refreshFiles();\r\n            resolve();\r\n          }\r\n        };\r\n      });\r\n      setBatchInfo({ current: i + 1, total: keys.length });\r\n    }\r\n    setBatchInfo(null);\r\n  };\r\n\r\n  return {\r\n    uploadAll,\r\n    batchInfo,\r\n  };\r\n}\r\n"
        }
    ]
}